---
title: INP Issues - All Causes & Fixes
description: Diagnose and fix Interaction to Next Paint issues. Complete guide to JavaScript execution, DOM operations, event handlers, and hydration problems.
navigation:
  title: All INP Issues
icon: i-heroicons-chart-bar
publishedAt: 2025-01-18
updatedAt: 2025-01-18
keywords:
  - inp issues
  - fix inp
  - slow interactions
  - javascript blocking
tags:
  - performance
  - inp
  - troubleshooting
---

# INP Issues & Fixes

Not sure why your interactions are slow? This page covers every common cause with links to detailed fix guides.

## Diagnose Your Issue

Before jumping into fixes, identify which phase of the interaction is slow.

**Chrome DevTools (Quick Check):**
1. Open DevTools → **Performance** tab
2. Check **"Web Vitals"** in settings (gear icon)
3. Click record → interact with the page (click buttons, type in inputs) → stop recording
4. Find the interaction in the timeline—hover to see duration
5. Look at the "Interactions" track to see which element was slow

**Check the breakdown:**
Each interaction has three phases. The Performance panel shows:
- **Input Delay**: Time between user action and handler starting (blue)
- **Processing Duration**: Time running your JavaScript (yellow/orange)
- **Presentation Delay**: Time for browser to render the result (green/purple)

**What to look for:**
- Is input delay high? → Main thread was blocked when user clicked
- Is processing duration high? → Your event handler is doing too much work
- Is presentation delay high? → DOM updates or layout are expensive

**Web Vitals Library (Production):**

```js
import { onINP } from 'web-vitals/attribution'

onINP((metric) => {
  const { inputDelay, processingDuration, presentationDelay } = metric.attribution
  console.log('INP:', metric.value, 'ms', metric.attribution.interactionTarget)
  console.log('Phases:', { inputDelay, processingDuration, presentationDelay })
})
```

## All INP Causes

### High Impact

These cause the biggest INP problems. Fix these first.

#### [Long-Running JavaScript](/learn-lighthouse/inp/fix/long-running-javascript)

JavaScript tasks over 50ms block the main thread. When a user clicks during a long task, they wait for it to finish before the browser can even start processing their click.

**Signs:** High input delay. Performance timeline shows long yellow/orange bars. TBT (Total Blocking Time) is high.

**Fix time:** Hours. Requires breaking up long tasks with `setTimeout`, `requestIdleCallback`, or yielding to the main thread.

#### [Heavy DOM Operations](/learn-lighthouse/inp/fix/heavy-dom-operations)

Large DOM updates, layout thrashing, and forced reflows slow down the presentation phase. [Presentation delay accounts for ~42% of total INP](https://www.corewebvitals.io/core-web-vitals/interaction-to-next-paint/presentation-delay) on average.

**Signs:** High presentation delay. Performance timeline shows purple "Layout" or "Paint" bars after your handler completes.

**Fix time:** Hours. Requires batching DOM updates, using `requestAnimationFrame`, or virtualizing large lists.

#### [Third-Party Scripts](/learn-lighthouse/inp/fix/third-party-scripts)

Analytics, ads, chat widgets, and marketing scripts compete for main thread time. They're a [major source of INP issues](https://web.dev/articles/optimize-inp), especially on mobile devices with slower CPUs.

**Signs:** High input delay that happens randomly. Long tasks in the Performance timeline that aren't your code.

**Fix time:** Minutes to hours. Move scripts to web workers, delay loading, or remove unnecessary ones.

### Medium Impact

These cause noticeable delays but are often secondary to the high-impact issues.

#### [Event Handler Delays](/learn-lighthouse/inp/fix/event-handler-delays)

Event handlers that do too much synchronous work before showing visual feedback. The user waits while your code processes data, makes API calls, or updates state.

**Signs:** High processing duration. Your handler code appears as a long block in the Performance timeline.

**Fix time:** Minutes. Prioritize UI updates, defer non-essential work, use optimistic updates.

#### [Hydration Issues](/learn-lighthouse/inp/fix/hydration-issues)

Framework hydration blocking interactivity in SSR apps. Users try to interact before the page is ready—the UI looks complete but doesn't respond.

**Signs:** Slow interactions only in the first few seconds after page load. Works fine after hydration completes.

**Fix time:** Hours to days. Requires architecture changes: progressive hydration, islands, or partial hydration.

### Lower Impact (But Common)

#### [DOM Size](/learn-lighthouse/inp/fix/dom-size)

Pages with over 800 DOM nodes take longer to update. Each interaction that modifies the DOM triggers style calculations, layout, and paint across more elements. The relationship isn't linear—doubling DOM size can quadruple style recalculation time.

**Signs:** Lighthouse "Avoid an excessive DOM size" warning. Presentation delay scales with page complexity.

**Fix time:** Hours. Virtualize long lists, remove hidden elements, flatten component nesting.

## Decision Tree

Not sure which cause applies? Work through this:

1. **Open DevTools Performance tab.** Record yourself interacting with the slow element.
2. **Check input delay.** Is it over 50ms?
   - Yes → Main thread was blocked → [Long-Running JavaScript](/learn-lighthouse/inp/fix/long-running-javascript) or [Third-Party Scripts](/learn-lighthouse/inp/fix/third-party-scripts)
   - No → Continue
3. **Check processing duration.** Is your handler taking over 100ms?
   - Yes → [Event Handler Delays](/learn-lighthouse/inp/fix/event-handler-delays)
   - No → Continue
4. **Check presentation delay.** Is rendering taking over 100ms?
   - Yes → [Heavy DOM Operations](/learn-lighthouse/inp/fix/heavy-dom-operations)
   - No → The issue might be intermittent or device-specific
5. **Is the problem only on initial page load?**
   - Yes → [Hydration Issues](/learn-lighthouse/inp/fix/hydration-issues)
   - No → Re-check with mobile CPU throttling enabled

## Framework-Specific Issues

Different frameworks have different common INP problems:

| Framework | Most Common INP Issues | Quick Fix |
|-----------|------------------------|-----------|
| **Next.js** | Hydration blocking, useEffect chains, state updates during render | Use Server Components, wrap updates in `startTransition` |
| **Nuxt** | Large payload size, hydration, reactive watchers | Reduce payload, use `lazy` prefix, debounce watchers |
| **React** | Re-render cascades, expensive computed values, unoptimized context | Memoize components, split contexts, use `useDeferredValue` |
| **Vue** | Reactivity overhead, large computed properties, deep watchers | Use `shallowRef`, cache expensive computed, avoid deep watch |
| **Angular** | Zone.js overhead, excessive change detection, template complexity | Use OnPush, detach change detection, simplify templates |
| **Svelte** | Reactive statement chains, large stores, DOM binding overhead | Use `tick()` for batching, split stores, minimize bindings |

→ See [framework-specific guides](/frameworks) for detailed walkthroughs.

## Test Every Page

Checking pages one-by-one is tedious. Different pages have different JavaScript, different event handlers, and different interaction patterns.

Your homepage might pass while your checkout fails. Product pages might be fast until someone opens the size selector or image gallery.

[Unlighthouse](/cloud) scans your entire site and surfaces TBT (INP proxy) issues across all pages. You'll see which templates have problems, which pages are outliers, and whether your fixes actually work at scale.

The CLI is free and runs locally. Cloud adds scheduled monitoring to catch regressions before users report them.

## Related

- [What is INP?](/learn-lighthouse/inp)
- [Fix LCP Issues](/learn-lighthouse/lcp/fix)
- [Fix CLS Issues](/learn-lighthouse/cls/fix)
- [Core Web Vitals Overview](/learn-lighthouse/core-web-vitals)
